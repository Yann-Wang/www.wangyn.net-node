<!DOCTYPE HTML><html><head><meta charset=utf-8><title>JavaScript中的this绑定 | Catullus | a Latin poet of the late Roman Republic</title><meta name=author content=Yann-Wang><meta name=description content=写技术，写心情，写日记><meta name=keywords content=this,bind><meta id=viewport name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta property=og:title content=JavaScript中的this绑定><meta property=og:site_name content=Catullus><meta property=og:image content=/favicon.ico><link href=/favicon.ico rel=icon><link rel=alternate href=/atom.xml title=Catullus type=application/atom+xml><link rel=stylesheet href=/css/style.css media=screen type=text/css></head><body><div class=blog><div class=content><header><div class=site-branding><h1 class=site-title><a href="/">Catullus</a></h1><p class=site-description>a Latin poet of the late Roman Republic</p></div><nav class=site-navigation><ul><li><a href="/">Home</a></li><li><a href=/archives>Archives</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class=article-title><span>JavaScript中的this绑定</span></h3><div class=article-top-meta><span class=posted-on><a href="/2016/06/03/the this binding in JavaScript/" rel=bookmark><time class="entry-date published" datetime=2016-06-03T03:44:51.000Z>2016-06-03</time></a></span></div><div class=article-content><div class=entry><h3 id=默认绑定：><a href=#默认绑定： class=headerlink title=默认绑定：></a>默认绑定：</h3><ul><li>non-strict mode ： this 指向全局对象；</li><li>strict mode : this 绑定 undefined<br>注：决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。</li></ul><h3 id=软绑定><a href=#软绑定 class=headerlink title=软绑定></a>软绑定</h3><ul><li>给默认绑定指定一个全局对象和undefined以外的值，可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改this的能力。</li><li><p>对指定的函数进行封装，首先检查调用时的this，如果this绑定到全局对象或者undefined， 那就把指定的默认对象obj绑定到this， 否则不会修改this。</p><a id=more></a><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre></td><td class=code><pre><span class=line> <span class=keyword>if</span> (!<span class=built_in>Function</span>.prototype.softBind)&#123;</span><br><span class=line>      <span class=built_in>Function</span>.prototype.softBind = <span class=function><span class=keyword>function</span>(<span class=params>obj</span>) </span>&#123;</span><br><span class=line>           <span class=keyword>var</span> fn = <span class=keyword>this</span>;  <span class=comment>// this指代的是调用softBind的那个函数对象，即foo</span></span><br><span class=line>           <span class=comment>//捕获所有curried参数</span></span><br><span class=line>           <span class=keyword>var</span> curried = [].slice.call(<span class=built_in>arguments</span>, <span class=number>1</span>);</span><br><span class=line>           <span class=keyword>var</span> bound   = <span class=function><span class=keyword>function</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>                <span class=keyword>return</span> fn.apply(</span><br><span class=line>                     (!<span class=keyword>this</span> || <span class=keyword>this</span> === (<span class=built_in>window</span> || global)) ? obj : <span class=keyword>this</span>,</span><br><span class=line>                     curried.concat.apply(curried, <span class=built_in>arguments</span>)</span><br><span class=line>                );</span><br><span class=line>           &#125;;</span><br><span class=line>           bound.prototype = <span class=built_in>Object</span>.create(fn.prototype);</span><br><span class=line>           <span class=keyword>return</span> bound;</span><br><span class=line>      &#125;;</span><br><span class=line> &#125;   </span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>foo</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>     <span class=built_in>console</span>.log(<span class=string>"name: "</span> + <span class=keyword>this</span>.name);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>var</span> obj  = &#123; name: <span class=string>"obj"</span> &#125;,</span><br><span class=line>    obj2 = &#123; name: <span class=string>"boj2"</span> &#125;,</span><br><span class=line>    obj3 = &#123; name: <span class=string>"obj3"</span> &#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>var</span> fooOBJ = foo.softBind(obj);</span><br><span class=line>fooOBJ(); <span class=comment>// name: obj   // 软绑定</span></span><br><span class=line></span><br><span class=line>obj2.foo = foo.softBind(obj);</span><br><span class=line>obj2.foo(); <span class=comment>// name: obj2     // 隐式绑定</span></span><br><span class=line></span><br><span class=line>fooOBJ.call(obj3); <span class=comment>// name: obj3   // 显式绑定</span></span><br><span class=line></span><br><span class=line>setTimeout(obj2.foo, <span class=number>10</span>); <span class=comment>// name: obj  // 软绑定  在浏览器中</span></span><br><span class=line><span class=comment>//javascript函数参数只能按值传递， 传参赋值造成了间接引用， 从而造成了隐式丢失，所以只剩下了软绑定</span></span><br><span class=line><span class=comment>//在nodejs中， 结果为：name: undefined    // 推理： 执行obj2.foo函数时，引用的变量obj 。。。。待续</span></span><br></pre></td></tr></table></figure></li></ul><h3 id=隐式绑定><a href=#隐式绑定 class=headerlink title=隐式绑定></a>隐式绑定</h3><ul><li>调用位置的上下文对象；</li><li>隐式丢失: 传入回调函数时会发生隐式赋值</li></ul><h3 id=显式绑定><a href=#显式绑定 class=headerlink title=显式绑定></a>显式绑定</h3><ul><li>.call</li><li>.apply</li><li><p>.forEach (not support es3)</p><p>Array.forEach(f[, o])</p></li></ul><p>- 如果指定了第二个参数o， 则执行显式绑定（通过apply实现），函数f的this绑定到o；</p><ul><li><p>硬绑定 （显式绑定的变种）：只能绑定一次，无法使用隐式绑定和显式绑定来修改this</p><ul><li><p>.bind (not support es3)</p><p>foo.bind(obj) 会返回一个硬编码的新函数， 它会把参数obj设置为this绑定并调用原始函数foo</p></li><li><p>手动硬绑定 会比bind函数的性能更好些</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>var</span> EventEmitter = <span class=built_in>require</span>(<span class=string>'events'</span>);</span><br><span class=line><span class=keyword>var</span> util = <span class=built_in>require</span>(<span class=string>'util'</span>);</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>MyThing</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>  EventEmitter.call(<span class=keyword>this</span>);</span><br><span class=line></span><br><span class=line>  doFirstThing();</span><br><span class=line>  setImmediate(emitThing1, <span class=keyword>this</span>);</span><br><span class=line>&#125;</span><br><span class=line>util.inherits(MyThing, EventEmitter);</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>emitThing1</span>(<span class=params>self</span>) </span>&#123;</span><br><span class=line>  self.emit(<span class=string>'thing1'</span>);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>var</span> mt = <span class=keyword>new</span> MyThing();</span><br><span class=line></span><br><span class=line>mt.on(<span class=string>'thing1'</span>, <span class=function><span class=keyword>function</span> <span class=title>onThing1</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>  <span class=comment>// Whoot!</span></span><br><span class=line>&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id=new绑定><a href=#new绑定 class=headerlink title=new绑定></a>new绑定</h3><ol><li><p>创建一个新对象；</p></li><li><p>调用构造函数产生的执行环境中的this指向这个新对象；</p></li><li><p>执行构造函数中的代码（为新对象添加属性）；</p></li><li><p>如果函数没有返回其它对象，那么返回这个新对象。</p></li></ol><h3 id=更安全的this><a href=#更安全的this class=headerlink title=更安全的this></a>更安全的this</h3><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>//空的非委托对象</span></span><br><span class=line><span class=keyword>var</span>   ∅ = <span class=built_in>Object</span>.create(<span class=literal>null</span>);</span><br></pre></td></tr></table></figure><ul><li><p>传给call, apply, bind</p></li><li><p>Object.create(null) 和 {} 很像， 但是并不会创建Object.prototype这个委托， 所以它比{} “更空”。</p></li></ul><h3 id=this间接引用><a href=#this间接引用 class=headerlink title=this间接引用></a>this间接引用</h3><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>foo</span>(<span class=params></span>)</span>&#123;</span><br><span class=line>     <span class=built_in>console</span>.log(<span class=keyword>this</span>.a);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>var</span> a = <span class=number>2</span>;</span><br><span class=line><span class=keyword>var</span> o = &#123; a: <span class=number>3</span>, foo: foo&#125;;</span><br><span class=line><span class=keyword>var</span> p = &#123; a: <span class=number>4</span>&#125;;</span><br><span class=line></span><br><span class=line>o.foo();  <span class=comment>// 3</span></span><br><span class=line></span><br><span class=line>(o.foo)();  <span class=comment>// 3</span></span><br><span class=line></span><br><span class=line>(p.foo = o.foo)();  <span class=comment>//  2     //赋值表达式的值 就是右操作数的值</span></span><br><span class=line></span><br><span class=line>p.foo();   <span class=comment>//  4</span></span><br><span class=line>(p.foo)();   <span class=comment>// 4</span></span><br><span class=line></span><br><span class=line><span class=keyword>var</span> bar = o.foo;</span><br><span class=line>bar();   <span class=comment>//  2</span></span><br></pre></td></tr></table></figure><ul><li>赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo()。</li></ul><h3 id=gt-箭头函数-this-绑定><a href=#gt-箭头函数-this-绑定 class=headerlink title="=&gt; 箭头函数 this 绑定"></a>=&gt; 箭头函数 this 绑定</h3><ul><li>继承外层作用域this 绑定</li><li>this 绑定不可被修改</li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/this/">this</a><a href="/tags/bind/">bind</a></span></div></div></article><div id=comment><div class=ds-thread data-thread-key="/2016/06/03/the this binding in JavaScript/" data-title=JavaScript中的this绑定 data-url="http://www.wangyn.net/2016/06/03/the this binding in JavaScript/"></div><script type=text/javascript>
	var duoshuoQuery = {short_name:"Yann-Wang"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script></div></main><footer class=site-footer><p class=site-info>Proudly powered by <a href="https://hexo.io/" target=_blank>Hexo</a> and Theme by <a href=https://github.com/CodeDaraW/Hacker target=_blank>Hacker</a><br>&copy; 2016 Yann-Wang</p></footer></div></div></body></html>