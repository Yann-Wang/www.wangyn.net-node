<!DOCTYPE HTML><html><head><meta charset=utf-8><title>v8在解析function声明和function调用时做了什么 | Catullus | a Latin poet of the late Roman Republic</title><meta name=author content=Yann-Wang><meta name=description content=写技术，写心情，写日记><meta name=keywords content="execution environment,function declaration,function call,v8"><meta id=viewport name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta property=og:title content=v8在解析function声明和function调用时做了什么><meta property=og:site_name content=Catullus><meta property=og:image content=/favicon.ico><link href=/favicon.ico rel=icon><link rel=alternate href=/atom.xml title=Catullus type=application/atom+xml><link rel=stylesheet href=/css/style.css media=screen type=text/css></head><body><div class=blog><div class=content><header><div class=site-branding><h1 class=site-title><a href="/">Catullus</a></h1><p class=site-description>a Latin poet of the late Roman Republic</p></div><nav class=site-navigation><ul><li><a href="/">Home</a></li><li><a href=/archives>Archives</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class=article-title><span>v8在解析function声明和function调用时做了什么</span></h3><div class=article-top-meta><span class=posted-on><a href="/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/" rel=bookmark><time class="entry-date published" datetime=2016-08-03T15:59:40.000Z>2016-08-03</time></a></span></div><div class=article-content><div class=entry><ul><li>本文来自w3c官方网站对 ES5标准文档<a href=https://www.w3.org/html/ig/zh/wiki/ES5/execution target=_blank rel=external>［可执行代码与执行环境］</a> 一文的部分引用</li></ul><h3 id=v8解析［function调用］时做了什么><a href=#v8解析［function调用］时做了什么 class=headerlink title=v8解析［function调用］时做了什么></a>v8解析［function调用］时做了什么</h3><ul><li><p>进入函数代码</p><p>当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入函数代码的执行环境时，执行以下步骤：</p><ol><li>如果函数代码是严格模式下的代码，设 this 绑定 为 thisArg。</li><li>否则如果 thisArg 是 null 或 undefined，则设 this 绑定 为全局对象。</li><li>否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定 为 ToObject(thisArg)。</li><li>否则设 this 绑定 为 thisArg。</li><li>以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment(见下边)，并令 localEnv 为调用的结果。</li><li>设 词法环境组件 为 localEnv。</li><li>设 变量环境组件 为 localEnv。</li><li>令 code 为 F 的 [[Code]] 内部属性的值。</li><li>按 10.5 描述的方案，使用函数代码 code 和 argumentList 执行声明式绑定初始化化步骤。<a id=more></a></li></ol></li><li><p>NewDeclarativeEnvironment(E)</p><p>当调用 NewDeclarativeEnvironment 抽象运算时，需指定一个词法环境 E，其值可以为 null，此时按以下步骤进行：</p><ol><li>令 env 为一个新建的词法环境。</li><li>令 envRec 为一个新建的声明式环境数据，该环境数据不包含任何绑定。</li><li>令 env 的环境数据为 envRec。</li><li>令 env 的外部词法环境引用至 E。</li><li>返回 env。</li></ol></li><li><p>声明式绑定初始化</p><p>每个执行环境都有一个关联的 变量环境组件。当在一个执行环境下评估一段 ECMA 脚本时，变量和函数定义会以绑定的形式添加到这个变量环境组件 的环境记录中。对于函数代码，参数也同样会以绑定的形式添加到这个 变量环境组件 的环境记录中。</p><p>选择使用哪一个、哪一类型的环境记录来绑定定义，是由执行环境下执行的 ECMA 脚本的类型决定的，而其它部分的逻辑是相同的。当进入一个执行环境时，会按以下步骤在 变量环境组件 上创建绑定，其中使用到调用者提供的代码设为 code，如果执行的是函数代码，则设参数列表为 args：</p><ol><li>令 env 为当前运行的执行环境的变量环境组件的环境记录项。</li><li>如果 code 是 eval 代码，则令 configurableBindings 为 true，否则令 configurableBindings 为 false。</li><li>如果代码是严格模式下的代码，则令 strict 为 true，否则令 strict 为 false。</li><li><p>如果代码为函数代码，则：</p><ol><li>令 func 为通过 [[Call]] 内部属性初始化 code 的执行的函数对象。令 names 为 func 的 [[FormalParameters]] 内部属性的值。</li><li>令 argCount 为 args 中元素的数量。</li><li>令 n 为数值 0。</li><li><p>按列表顺序遍历 names，对于每一个字符串 argName：</p><ol><li>令 n 的值为 n 当前值加 1。</li><li>如果 n 大于 argCount，则令 v 为 undefined，否则令 v 为 args 中的第 n 个元素。</li><li>以 argName 为参数，调用 env 的 HasBinding 具体方法，并令 argAlreadyDeclared 为调用的结果。</li><li>如果 argAlreadyDeclared 的值为 false，以 argName 为参数调用 env 的 CreateMutableBinding 具体方法。</li><li>以 argName、v 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。</li></ol></li></ol></li><li><p>按源码顺序遍历 code，对于每一个 FunctionDeclaration f：</p><ol><li>令 fn 为 FunctionDeclaration f 中的 Identifier。</li><li>按第 13 章中所述的步骤初始化 FunctionDeclaration f ，并令 fo 为初始化的结果。</li><li>以 fn 为参数，调用 env 的 HasBinding 具体方法，并令 argAlreadyDeclared 为调用的结果。</li><li>如果 argAlreadyDeclared 的值为 false，以 fn 和 configurableBindings 为参数调用 env 的 CreateMutableBinding 具体方法。</li><li><p>否则如果 env 是全局环境的环境记录对象，则：</p><ol><li>令 go 为全局对象。</li><li>以 fn 为参数，调用 go 和 [[GetProperty]] 内部方法，并令 existingProp 为调用的结果。</li><li><p>如果 existingProp.[[Configurable]] 的值为 true，则：</p><ol><li>以 fn、由 {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configurableBindings } 组成的属性描述符和 true 为参数，调用 go 的 [[DefineOwnProperty]] 内部方法。</li></ol></li><li><p>否则如果 IsAccessorDescriptor(existingProp) 的结果为真，或 existingProp 的特性中没有 {[[Writable]]: true, [[Enumerable]]: true}，则：</p><ol><li>抛出一个 TypeError 异常。</li></ol></li></ol></li><li><p>以 fn、fo 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。</p></li></ol></li><li><p>以 “arguments” 为参数，调用 env 的 HasBinding 具体方法，并令 argumentsAlreadyDeclared 为调用的结果。</p></li><li>如果 code 是函数代码，并且 argumentsAlreadyDeclared 为 false，则：<ol><li>以 fn、names、args、env 和 strict 为参数，调用 CreateArgumentsObject 抽象运算函数，并令 argsObj 为调用的结果。</li><li>如果 strict 为 true，则：<ol><li>以字符串”arguments”为参数，调用 env 的 CreateImmutableBinding 具体方法。</li><li>以字符串 “arguments” 和 argsObj 为参数，调用 env 的 InitializeImmutableBinding 具体函数。</li></ol></li><li>否则：<ol><li>以字符串 “arguments”为参数，调用 env 的 CreateMutableBinding 具体方法。</li><li>以字符串”arguments”、argsObj 和 false 为参数，调用 env 的 SetMutableBinding 具体函数。</li></ol></li></ol></li><li>按源码顺序遍历 code，对于每一个 VariableDeclaration 和 VariableDeclarationNoIn 表达式作为 d 执行：<ol><li>令 dn 为 d 中的标识符。</li><li>以 dn 为参数，调用 env 的 HasBinding 具体方法，并令 varAlreadyDeclared 为调用的结果。</li><li>如果 varAlreadyDeclared 为 false，则：<ol><li>以 dn 和 configurableBindings 为参数，调用 env 的 CreateMutableBinding 具体方法。</li><li>以 dn、undefined 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。</li></ol></li></ol></li></ol></li></ul><h3 id=v8解析［function定义］时做了什么><a href=#v8解析［function定义］时做了什么 class=headerlink title=v8解析［function定义］时做了什么></a>v8解析［function定义］时做了什么</h3><h4 id=按源码顺序遍历-code，对于每一个-FunctionDeclaration-f：><a href=#按源码顺序遍历-code，对于每一个-FunctionDeclaration-f： class=headerlink title="按源码顺序遍历 code，对于每一个 FunctionDeclaration f："></a>按源码顺序遍历 code，对于每一个 FunctionDeclaration f：</h4><ol><li>令 fn 为 FunctionDeclaration f 中的 Identifier。</li><li>按第 13 章中所述的步骤初始化 FunctionDeclaration f ，并令 fo 为初始化的结果。</li><li>以 fn 为参数，调用 env 的 HasBinding 具体方法，并令 argAlreadyDeclared 为调用的结果。</li><li>如果 argAlreadyDeclared 的值为 false，以 fn 和 configurableBindings 为参数调用 env 的 CreateMutableBinding 具体方法。</li><li><p>否则如果 env 是全局环境的环境记录对象，则：</p><ol><li>令 go 为全局对象。</li><li>以 fn 为参数，调用 go 和 [[GetProperty]] 内部方法，并令 existingProp 为调用的结果。</li><li><p>如果 existingProp.[[Configurable]] 的值为 true，则：</p><ol><li>以 fn、由 {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configurableBindings } 组成的属性描述符和 true 为参数，调用 go 的 [[DefineOwnProperty]] 内部方法。</li></ol></li><li><p>否则如果 IsAccessorDescriptor(existingProp) 的结果为真，或 existingProp 的特性中没有 {[[Writable]]: true, [[Enumerable]]: true}，则：</p><ol><li>抛出一个 TypeError 异常。</li></ol></li></ol></li><li><p>以 fn、fo 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。</p></li></ol><h4 id=初始化-FunctionDeclaration-f><a href=#初始化-FunctionDeclaration-f class=headerlink title="初始化 FunctionDeclaration f :"></a>初始化 FunctionDeclaration f :</h4><p>产生式 FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody } 依照定义绑定初始化 (10.5) 如下初始化：</p><ol><li>依照 13.2，指定 FormalParameterListopt 为参数列表，指定 FunctionBody 为 函数体，创建一个新函数对象(见 3&gt;)，返回结果。运行中的执行环境的 VariableEnvironment 传递为 Scope。如果 FunctionDeclaration 包含在严格模式代码里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。</li></ol><p>产生式 FunctionExpression : function ( FormalParameterListopt ) { FunctionBody } 的解释执行如下：</p><ol><li>依照 13.2，指定 FormalParameterListopt 为参数列表，指定 FunctionBody 为 函数体，创建一个新函数对象，返回结果。运行中的执行环境的 LexicalEnvironment 传递为Scope。如果 FunctionExpression 包含在严格模式代码里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。</li></ol><p>产生式 FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody } 的解释执行如下：</p><ol><li>令 funcEnv 为以运行中执行环境的 LexicalEnvironment 为参数调用 NewDeclarativeEnvironment 的结果。</li><li>令 envRec 为 funcEnv 的环境记录项。</li><li>以 Identifier 的字符串值为参数调用 envRec 的具体方法 CreateImmutableBinding(N)。</li><li>令 closure 为依照 13.2，指定 FormalParameterListopt 为参数，指定 FunctionBody 为 函数体，创建一个新函数对象的结果。传递 funcEnv 为 Scope。如果FunctionExpression 包含在严格模式代码里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。</li><li>以 Identifier 的字符串值和 closure 为参数调用 envRec 的具体方法 InitializeImmutableBinding(N,V)。</li><li>返回 closure。</li></ol><p>注： 可以从 FunctionExpression 的 FunctionBody 里面引用 FunctionExpression 的 Identifier，以允许函数递归调用自身。然而不像FunctionDeclaration，FunctionExpression 的 Identifier 不能被范围封闭的 FunctionExpression 引用，也不会影响它。</p><h4 id=创建一个新函数对象><a href=#创建一个新函数对象 class=headerlink title=创建一个新函数对象:></a>创建一个新函数对象:</h4><p>指定 FormalParameterList 为可选的 参数列表，指定 FunctionBody 为 函数体，指定 Scope 为词法环境，Strict 为布尔标记，按照如下步骤构建函数对象：</p><ol><li>创建一个新的 ECMAScript 原生对象，令 F 为此对。</li><li>依照 8.12 描述设定 F 的除 [[Get]] 以外的所有内部方法。</li><li>设定 F 的 [[Class]] 内部属性为 “Function”。</li><li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 对象的 prototype 属性。</li><li>依照 15.3.5.4 描述，设定 F 的 [[Get]] 内部属性。</li><li>依照 13.2.1 描述，设定 F 的 [[Call]] 内部属性。</li><li>依照 13.2.2 描述，设定 F 的 [[Construct]] 内部属性。</li><li>依照 15.3.5.3 描述，设定 F 的 [[HasInstance]] 内部属性。</li><li>设定 F 的 [[Scope]] 内部属性为 Scope 的值。</li><li>令 names 为一个列表容器，其中元素是以从左到右的文本顺序对应 FormalParameterList 的标识符的字符串。</li><li>设定 F 的 [[FormalParameters]] 内部属性为 names。</li><li>设定 F 的 [[Code]] 内部属性为 FunctionBody。</li><li>设定 F 的 [[Extensible]] 内部属性为 true。</li><li>令 len 为 FormalParameterList 指定的形式参数的个数。如果没有指定参数，则令 len 为 0。</li><li>以参数 “length”、属性描述符 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li><li>令 proto 为仿佛使用 new Object() 表达式创建新对象的结果，其中 Object 是标准内置构造器名。</li><li>以参数 “constructor”、属性描述符 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、false 调用 proto 的 [[DefineOwnProperty]] 内部方法。</li><li>以参数 “prototype”、属性描述符 {[[Value]]: proto, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}、false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li><li><p>如果 Strict 是 true，则</p><ol><li>令 thrower 为 [[ThrowTypeError]] 函数对象（13.2.3）。</li><li>以参数 “caller”、属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li><li>以参数 “arguments”、属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li></ol></li><li><p>返回 F。</p></li></ol><p>注：每个函数都会自动创建一个 prototype 属性，以满足函数会被当作构造器的可能性。</p><h4 id=Call><a href=#Call class=headerlink title=[[Call]]></a>[[Call]]</h4><p>当用一个 this 值、一个参数列表调用函数对象 F 的 [[Call]] 内部方法，采用以下步骤：</p><ol><li>用 F 的 [[FormalParameters]] 内部属性值、参数列表 args、10.4.3 描述的 this 值来建立函数代码的一个新执行环境，令 funcCtx 为其结果。</li><li>令 result 为 FunctionBody（也就是 F 的 [[Code]] 内部属性）解释执行的结果。如果 F 没有 [[Code]] 内部属性或其值是空的 FunctionBody，则 result 是 (normal,undefined, empty)。</li><li>退出 funcCtx 运行环境，恢复到之前的执行运行环境。</li><li>如果 result.type 是 throw 则抛出 result.value。</li><li>如果 result.type 是 return 则返回 result.value。</li><li>否则 result.type 必定是 normal。返回 undefined。</li></ol><h4 id=Construct><a href=#Construct class=headerlink title=[[Construct]]></a>[[Construct]]</h4><p>当以一个可能的空的参数列表调用函数对象 F 的 [[Construct]] 内部方法，采用以下步骤：</p><ol><li>令 obj 为新创建的 ECMAScript 原生对象。</li><li>依照 8.12 设定 obj 的所有内部方法。</li><li>设定 obj 的 [[Class]] 内部属性为 “Object”。</li><li>设定 obj 的 [[Extensible]] 内部属性为 true。</li><li>令 proto 为以参数 “prototype” 调用 F 的 [[Get]] 内部属性的值。</li><li>如果 Type(proto) 是 Object，设定 obj 的 [[Prototype]] 内部属性为 proto。</li><li>如果 Type(proto) 不是 Object，设定 obj 的 [[Prototype]] 内部属性为 15.2.4 描述的标准内置的 Object 原型对象。</li><li>以 obj 为 this 值，调用 [[Construct]] 的参数列表为 args，调用 F 的 [[Call]] 内部属性，令 result 为调用结果。</li><li>如果 Type(result) 是 Object，则返回 result。</li><li>返回 obj。</li></ol><h4 id=ThrowTypeError-函数对象><a href=#ThrowTypeError-函数对象 class=headerlink title="[[ThrowTypeError]] 函数对象"></a>[[ThrowTypeError]] 函数对象</h4><p>[[ThrowTypeError]] 对象是个唯一的函数对象，如下只定义一次：</p><ol><li>创建一个新 ECMAScript 原生对象，令 F 为此对象。</li><li>依照 8.12 设定 F 的所有内部属性。</li><li>设定 F 的 [[Class]] 内部属性为 “Function”。</li><li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 的原型对象。</li><li>依照 13.2.1 描述设定 F 的 [[Call]] 内部属性。</li><li>设定 F 的 [[Scope]] 内部属性为全局环境。</li><li>设定 F 的 [[FormalParameters]] 内部属性为一个空列表。</li><li>设定 F 的 [[Code]] 内部属性为一个 FunctionBody，它无条件抛出一个 TypeError 异常，不做其他事情。</li><li>以参数 “length”、属性描述符 {[[Value]]: 0, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li><li>设定 F 的 [[Extensible]] 内部属性为 false。</li><li>令 [[ThrowTypeError]] 为 F。</li></ol></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/execution-environment/">execution environment</a><a href="/tags/function-declaration/">function declaration</a><a href="/tags/function-call/">function call</a><a href="/tags/v8/">v8</a></span></div></div></article><div id=comment><div class=ds-thread data-thread-key="/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/" data-title=v8在解析function声明和function调用时做了什么 data-url="http://www.wangyn.net/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/"></div><script type=text/javascript>
	var duoshuoQuery = {short_name:"Yann-Wang"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script></div></main><footer class=site-footer><p class=site-info>Proudly powered by <a href="https://hexo.io/" target=_blank>Hexo</a> and Theme by <a href=https://github.com/CodeDaraW/Hacker target=_blank>Hacker</a><br>&copy; 2016 Yann-Wang</p></footer></div></div></body></html>