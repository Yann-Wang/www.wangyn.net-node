<!DOCTYPE HTML><html><head><meta charset=utf-8><title>Page 3 | Catullus | a Latin poet of the late Roman Republic</title><meta name=author content=Yann-Wang><meta name=description content=写技术，写心情，写日记><meta id=viewport name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta property=og:site_name content=Catullus><meta property=og:image content=/favicon.ico><link href=/favicon.ico rel=icon><link rel=alternate href=/atom.xml title=Catullus type=application/atom+xml><link rel=stylesheet href=/css/style.css media=screen type=text/css></head><body><div class=blog><div class=content><header><div class=site-branding><h1 class=site-title><a href="/">Catullus</a></h1><p class=site-description>a Latin poet of the late Roman Republic</p></div><nav class=site-navigation><ul><li><a href="/">Home</a></li><li><a href=/archives>Archives</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class=article-title><a href="/2016/07/16/cross-origin request technology/"><span>跨域请求技术</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/07/16/cross-origin request technology/" rel=bookmark><time class="entry-date published" datetime=2016-07-16T13:40:55.000Z>2016-07-16</time></a></span></div><div class=article-content><div class=entry><ol><li><p>跨域资源共享CORS（Cross-Origin Resource Sharing）——<strong>xhr 需要服务端返回带有 <code>Access-Control-Allow-Origin</code> 的响应头</strong></p></li><li><p>图像Ping——<strong>动态生成img标签</strong></p></li><li><p>JSONP——<strong>动态生成script标签</strong></p></li><li><p>Comet <code>[&#39;kɒmɪt]</code>——<strong>长链接 http 流</strong></p></li><li><p>服务器发送事件——<strong>EventSource 对象</strong></p></li><li><p>Web Socket——<strong>WebSocket 对象</strong></p></li></ol></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/cross-origin/">cross origin</a><a href="/tags/CORS/">CORS</a><a href="/tags/imgPing/">imgPing</a><a href="/tags/jsonp/">jsonp</a><a href="/tags/Comet/">Comet</a><a href="/tags/Server-Sent-Events/">Server-Sent Events</a><a href="/tags/Web-Socket/">Web Socket</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href="http://www.wangyn.net/2016/07/16/cross-origin request technology/#comment">Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/07/03/the-inner-implementing-of-async-module-in-Node-js/"><span>Node.js中的async模块的内部实现</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/07/03/the-inner-implementing-of-async-module-in-Node-js/" rel=bookmark><time class="entry-date published" datetime=2016-07-03T03:44:51.000Z>2016-07-03</time></a></span></div><div class=article-content><div class=entry><h3 id=Async-js中的-each和-eachSeries><a href=#Async-js中的-each和-eachSeries class=headerlink title=Async.js中的.each和.eachSeries></a>Async.js中的.each和.eachSeries</h3><ul><li>.each 并不是真正的并行，而是.each中的函数有异步回调，.each不能保证每次调用异步回调都是按先后顺序调用的。也就是说，并行的是回调函数（此处的并行，并不是系统层面的并行）。</li><li>.each实现思路：顺序遍历执行数组中的函数，声明一个变量count=0，在每个callback函数中 将count++，然后判断count 是否与数组.length相等，如果等，就调用最后的callback。</li><li>.eachSeries实现思路：在前一个的callback函数中调用后一个函数。</li><li><p>async.series也是根据.eachSeries来实现的。</p></li><li><p><a href=https://github.com/caolan/async/blob/v1.5.2/lib/async.js>Async.js v1.5.2版本</a></p></li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/async/">async</a><a href="/tags/inner-implementing/">inner implementing</a><a href="/tags/source-code/">source code</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href=http://www.wangyn.net/2016/07/03/the-inner-implementing-of-async-module-in-Node-js/#comment>Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/06/03/the this binding in JavaScript/"><span>JavaScript中的this绑定</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/06/03/the this binding in JavaScript/" rel=bookmark><time class="entry-date published" datetime=2016-06-03T03:44:51.000Z>2016-06-03</time></a></span></div><div class=article-content><div class=entry><h3 id=默认绑定：><a href=#默认绑定： class=headerlink title=默认绑定：></a>默认绑定：</h3><ul><li>non-strict mode ： this 指向全局对象；</li><li>strict mode : this 绑定 undefined<br>注：决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。</li></ul><h3 id=软绑定><a href=#软绑定 class=headerlink title=软绑定></a>软绑定</h3><ul><li>给默认绑定指定一个全局对象和undefined以外的值，可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改this的能力。</li><li><p>对指定的函数进行封装，首先检查调用时的this，如果this绑定到全局对象或者undefined， 那就把指定的默认对象obj绑定到this， 否则不会修改this。</p></li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/this/">this</a><a href="/tags/bind/">bind</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href="http://www.wangyn.net/2016/06/03/the this binding in JavaScript/#comment">Comments</a></span></span></div></div></article><nav class=pagination><a href="/page/2/" class=pagination-prev>Prev</a></nav></main><footer class=site-footer><p class=site-info>Proudly powered by <a href="https://hexo.io/" target=_blank>Hexo</a> and Theme by <a href=https://github.com/CodeDaraW/Hacker target=_blank>Hacker</a><br>&copy; 2016 Yann-Wang</p></footer></div></div></body></html>