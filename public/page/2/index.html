<!DOCTYPE HTML><html><head><meta charset=utf-8><title>Page 2 | Catullus | a Latin poet of the late Roman Republic</title><meta name=author content=Yann-Wang><meta name=description content=写技术，写心情，写日记><meta id=viewport name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta property=og:site_name content=Catullus><meta property=og:image content=/favicon.ico><link href=/favicon.ico rel=icon><link rel=alternate href=/atom.xml title=Catullus type=application/atom+xml><link rel=stylesheet href=/css/style.css media=screen type=text/css></head><body><div class=blog><div class=content><header><div class=site-branding><h1 class=site-title><a href="/">Catullus</a></h1><p class=site-description>a Latin poet of the late Roman Republic</p></div><nav class=site-navigation><ul><li><a href="/">Home</a></li><li><a href=/archives>Archives</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class=article-title><a href="/2016/09/20/Is-JavaScript-one-of-functional-language/"><span>JavaScript是函数式语言吗？</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/09/20/Is-JavaScript-one-of-functional-language/" rel=bookmark><time class="entry-date published" datetime=2016-09-20T12:40:55.000Z>2016-09-20</time></a></span></div><div class=article-content><div class=entry><ul><li>javascript 属于没有明确归类的语言，或者好听点叫“多范式语言”。</li><li>你可以用原型继承模拟一套面向对象的体系，也可以强迫自己写函数式的 javascript（因为函数在 js 里是一等公民），也可以怎么舒服怎么写。</li></ul><h4 id=javascript语言继承的函数式语言的特点><a href=#javascript语言继承的函数式语言的特点 class=headerlink title=javascript语言继承的函数式语言的特点></a>javascript语言继承的函数式语言的特点</h4><ul><li>高阶函数（Higher-order function）<ul><li>函数参数和函数返回值都可以是函数</li></ul></li><li>偏应用函数（Partially Applied Functions）和 柯里化（Currying）<ul><li>偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值。</li><li>curry2这个函数非常有用但它仅仅适用于二元函数。大多数的函数式编程语言都在语法上内置了柯里化，但是JavaScript并没有。</li><li>但JavaScript提供了一些非常有用的函数，像Function.prototype.call, Function.prototype.bind, 和与众不同的 arguments 对象。能够利用这些函数实现一些强大的函数式编程所约定的。（像柯里化）</li></ul></li><li>闭包（closure）<ul><li>闭包的基础：函数是一等公民（First-class function）</li></ul></li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/functional-language/">functional language</a><a href="/tags/javascript/">javascript</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href=http://www.wangyn.net/2016/09/20/Is-JavaScript-one-of-functional-language/#comment>Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/09/16/the feature of functional language/"><span>函数式语言的特点</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/09/16/the feature of functional language/" rel=bookmark><time class="entry-date published" datetime=2016-09-16T13:40:55.000Z>2016-09-16</time></a></span></div><div class=article-content><div class=entry><h3 id=概念><a href=#概念 class=headerlink title=概念></a>概念</h3><h4 id=编程范式><a href=#编程范式 class=headerlink title=编程范式></a>编程范式</h4><ul><li>函数式编程是一种编程范式，我们常见的编程范式有命令式编程（Imperative programming），函数式编程，逻辑式编程，常见的面向对象编程是也是一种命令式编程。</li><li>命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），一句话，命令式程序就是一个冯诺依曼机的指令序列。</li><li>而函数式编程是面向数学的抽象，将计算描述为一种表达式求值，一句话，函数式程序就是一个表达式。</li></ul><h4 id=编程范型和编程语言之间的关系><a href=#编程范型和编程语言之间的关系 class=headerlink title=编程范型和编程语言之间的关系></a>编程范型和编程语言之间的关系</h4><ul><li>编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。</li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/functional-language/">functional language</a><a href="/tags/functional-programming/">functional programming</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href="http://www.wangyn.net/2016/09/16/the feature of functional language/#comment">Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/08/24/promise implementing and analysis/"><span>v8在解析promise源码时的执行环境变化过程</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/08/24/promise implementing and analysis/" rel=bookmark><time class="entry-date published" datetime=2016-08-24T13:40:55.000Z>2016-08-24</time></a></span></div><div class=article-content><div class=entry><ul><li><p>首先，先去<a href="https://www.promisejs.org/implementing/">Promise官网</a>看implementing这篇文章．</p></li><li><p>下面是我对源码的一个解读</p><iframe scrolling=no width=100% height=300 src=http://jsfiddle.net/01duqtsu/embedded/js,html,result/light frameborder=0 allowfullscreen></iframe></li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/promise/">promise</a><a href="/tags/execution-environment/">execution environment</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href="http://www.wangyn.net/2016/08/24/promise implementing and analysis/#comment">Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/"><span>v8在解析function声明和function调用时做了什么</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/" rel=bookmark><time class="entry-date published" datetime=2016-08-03T15:59:40.000Z>2016-08-03</time></a></span></div><div class=article-content><div class=entry><ul><li>本文来自w3c官方网站对 ES5标准文档<a href=https://www.w3.org/html/ig/zh/wiki/ES5/execution>［可执行代码与执行环境］</a> 一文的部分引用</li></ul><h3 id=v8解析［function调用］时做了什么><a href=#v8解析［function调用］时做了什么 class=headerlink title=v8解析［function调用］时做了什么></a>v8解析［function调用］时做了什么</h3><ul><li><p>进入函数代码</p><p>当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入函数代码的执行环境时，执行以下步骤：</p><ol><li>如果函数代码是严格模式下的代码，设 this 绑定 为 thisArg。</li><li>否则如果 thisArg 是 null 或 undefined，则设 this 绑定 为全局对象。</li><li>否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定 为 ToObject(thisArg)。</li><li>否则设 this 绑定 为 thisArg。</li><li>以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment(见下边)，并令 localEnv 为调用的结果。</li><li>设 词法环境组件 为 localEnv。</li><li>设 变量环境组件 为 localEnv。</li><li>令 code 为 F 的 [[Code]] 内部属性的值。</li><li>按 10.5 描述的方案，使用函数代码 code 和 argumentList 执行声明式绑定初始化化步骤。</li></ol></li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/execution-environment/">execution environment</a><a href="/tags/function-declaration/">function declaration</a><a href="/tags/function-call/">function call</a><a href="/tags/v8/">v8</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href=http://www.wangyn.net/2016/08/03/what-happened-when-v8-parse-function-declaration-and-function-called/#comment>Comments</a></span></span></div></div></article><article><h3 class=article-title><a href="/2016/07/25/the-executing-procedure-of-javascript-new-operation/"><span>JavaScript new 操作符的执行过程</span></a></h3><div class=article-top-meta><span class=posted-on><a href="/2016/07/25/the-executing-procedure-of-javascript-new-operation/" rel=bookmark><time class="entry-date published" datetime=2016-07-25T02:39:06.000Z>2016-07-25</time></a></span></div><div class=article-content><div class=entry><h3 id=《JavaScript高级程序设计》中的描述><a href=#《JavaScript高级程序设计》中的描述 class=headerlink title=《JavaScript高级程序设计》中的描述></a>《JavaScript高级程序设计》中的描述</h3><ul><li><p>使用new 操作符调用构造函数，会进行以下步骤：</p><ol><li>创建一个新函数对象；</li><li>调用构造函数产生的执行环境中的this指向这个新对象； //该构造函数 不是 新对象 的方法</li><li>执行构造函数中的代码（为新函数对象添加属性）；</li><li>如果函数没有返回其它对象，那么返回这个新函数对象。</li></ol></li><li><p>构造函数的prototype属性被用作新对象的原型</p></li><li>以上是一个原子操作过程。</li></ul></div></div><div class=article-footer><div class="article-meta pull-left"><span class=post-categories><i class=icon-categories></i> <a href="/categories/technology/">technology</a></span> <span class=post-tags><i class=icon-tags></i> <a href="/tags/execution-environment/">execution environment</a><a href="/tags/new/">new</a><a href="/tags/operation/">operation</a></span></div><div class="article-meta pull-right"><span><i class=icon-comments></i> <span><a href=http://www.wangyn.net/2016/07/25/the-executing-procedure-of-javascript-new-operation/#comment>Comments</a></span></span></div></div></article><nav class=pagination><a href="/" class=pagination-prev>Prev</a> <a href="/page/3/" class=pagination-next>Next</a></nav></main><footer class=site-footer><p class=site-info>Proudly powered by <a href="https://hexo.io/" target=_blank>Hexo</a> and Theme by <a href=https://github.com/CodeDaraW/Hacker target=_blank>Hacker</a><br>&copy; 2016 Yann-Wang</p></footer></div></div></body></html>